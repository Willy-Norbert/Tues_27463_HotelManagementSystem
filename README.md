# Hotel Management System â€“ Oracle PL/SQL Capstone Project

## ðŸ“˜ Project Description

The **Hotel Management System** is designed to solve common issues in hotels, guesthouses, and resorts that rely on manual booking systems. Such systems often suffer from overbooking, billing errors, poor service tracking, and data mismanagement. This project leverages **Oracle PL/SQL** to create an automated system that handles:

- Room bookings
- Guest information
- Payments and billing
- Service requests
- Employee tracking
- Security and auditing

The system improves efficiency, minimizes human error, and ensures secure, accurate record-keeping. The solution integrates multiple PL/SQL features such as **procedures, triggers, compound triggers, exception handling, and audit logs**.

The following steps describe the implementation of the system in detail, including all SQL code and the expected result of each step.

---

## âœ… Enable DBMS Output

To display output messages from PL/SQL blocks, especially from `DBMS_OUTPUT.PUT_LINE`, we must enable server output.

```sql
SET SERVEROUTPUT ON;
```

This command ensures that the messages printed within procedures and exception blocks will appear in the SQL Developer output window.

![Screenshot](screenshots/step0_enable_output.png)

---

## âœ… Step 1: Add Gender Column to the Guests Table

In this step, we extend the `Guests` table by adding a new column called `Gender`. Since this alteration should only occur once, we use dynamic SQL with exception handling to avoid errors if the column already exists.

```sql
BEGIN
  EXECUTE IMMEDIATE 'ALTER TABLE Guests ADD Gender VARCHAR2(10)';
EXCEPTION
  WHEN OTHERS THEN
    IF SQLCODE = -01430 THEN
      DBMS_OUTPUT.PUT_LINE('Column already exists.');
    ELSE
      RAISE;
    END IF;
END;
/
```

This ensures the database schema includes gender information while maintaining system stability during repeated deployments.

![Screenshot](screenshots/step1_alter_table.png)

---

## âœ… Step 2: Perform Sample DML Operations

To test how the system handles data manipulation, we perform the following actions:

- Update a guest's contact information
- Delete a payment record
- Insert a new room with a unique ID

```sql
UPDATE Guests SET Contact = '0788001121' WHERE GuestID = 1;
DELETE FROM Payments WHERE PaymentID = 10;
INSERT INTO Rooms VALUES (112, 'Single', 48000, 'Available');
```

These operations verify that table structures are functioning correctly and constraints are properly set.

![Screenshot](screenshots/step2_dml_operations.png)

---

## âœ… Step 3: Create Procedure to Summarize Guest Bookings and Payments

We implement a stored procedure called `GetGuestSummary` that accepts a guest ID and displays the total number of bookings and the total payment amount made by that guest.

```sql
CREATE OR REPLACE PROCEDURE GetGuestSummary (
  p_guest_id IN Guests.GuestID%TYPE
) AS
  v_total_bookings NUMBER := 0;
  v_total_paid NUMBER(10,2) := 0;
BEGIN
  SELECT COUNT(*), NVL(SUM(p.Amount), 0)
  INTO v_total_bookings, v_total_paid
  FROM Bookings b
  LEFT JOIN Payments p ON b.BookingID = p.BookingID
  WHERE b.GuestID = p_guest_id;

  DBMS_OUTPUT.PUT_LINE('Guest ID: ' || p_guest_id);
  DBMS_OUTPUT.PUT_LINE('Total Bookings: ' || v_total_bookings);
  DBMS_OUTPUT.PUT_LINE('Total Paid: ' || v_total_paid);
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;
/
```

This procedure is critical for generating personalized billing summaries and reports for guests.

![Screenshot](screenshots/step3_procedure_summary.png)

---

## âœ… Step 4: Create Holidays Table

We now define a `Holidays` table to record national holidays. This table will later be referenced in a trigger to restrict database operations on holidays.

```sql
BEGIN
  EXECUTE IMMEDIATE 'DROP TABLE Holidays CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

CREATE TABLE Holidays (
  HolidayDate DATE PRIMARY KEY,
  Description VARCHAR2(100)
);

INSERT INTO Holidays VALUES (TO_DATE('2025-05-17', 'YYYY-MM-DD'), 'Independence Day');
INSERT INTO Holidays VALUES (TO_DATE('2025-05-23', 'YYYY-MM-DD'), 'National Heroes Day');
COMMIT;
```

This ensures our system can adapt to calendar-based restrictions.

![Screenshot](screenshots/step4_create_holidays.png)

---

## âœ… Step 5: Create Audit_Log Table

To track system activity, we introduce an `Audit_Log` table that stores who performed what operation, on which table, and whether it was allowed.

```sql
BEGIN
  EXECUTE IMMEDIATE 'DROP TABLE Audit_Log CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

CREATE TABLE Audit_Log (
  AuditID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  UserName VARCHAR2(50),
  ActionDate DATE,
  Operation VARCHAR2(10),
  TableName VARCHAR2(30),
  Status VARCHAR2(10)
);
```

This table is essential for accountability and system monitoring.

![Screenshot](screenshots/step5_create_audit_log.png)

---

## âœ… Step 6: Create Audit Logging Procedure

We implement a procedure called `log_audit_action` to simplify the process of writing entries into the audit log. This uses an autonomous transaction to ensure audit logs are saved even if the calling transaction fails.

```sql
CREATE OR REPLACE PROCEDURE log_audit_action (
  p_user     VARCHAR2,
  p_action   VARCHAR2,
  p_table    VARCHAR2,
  p_status   VARCHAR2
) IS
  PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
  INSERT INTO Audit_Log (UserName, ActionDate, Operation, TableName, Status)
  VALUES (p_user, SYSDATE, p_action, p_table, p_status);
  COMMIT;
END;
/
```

This procedure improves code reuse and makes auditing consistent.

![Screenshot](screenshots/step6_audit_procedure.png)

---

## âœ… Step 7: Create Trigger to Restrict Operations on Weekdays and Holidays

We create a trigger that blocks operations on the `Guests` table by a specific user (`IRABARUTA`) during weekdays and on public holidays. It also logs the action.

```sql
CREATE OR REPLACE TRIGGER trg_block_weekday_holiday_ops
BEFORE INSERT OR UPDATE OR DELETE ON Guests
FOR EACH ROW
DECLARE
  v_day VARCHAR2(10);
  v_holiday NUMBER := 0;
  v_username VARCHAR2(50);
BEGIN
  v_username := SYS_CONTEXT('USERENV', 'SESSION_USER');
  
  SELECT TO_CHAR(SYSDATE, 'DY', 'NLS_DATE_LANGUAGE=''ENGLISH''') INTO v_day FROM DUAL;
  SELECT COUNT(*) INTO v_holiday FROM Holidays WHERE HolidayDate = TRUNC(SYSDATE);

  IF UPPER(v_username) = 'IRABARUTA' AND 
     (v_day IN ('MON', 'TUE', 'WED', 'THU', 'FRI') OR v_holiday > 0) THEN
    log_audit_action(v_username, 'BLOCKED', 'GUESTS', 'DENIED');
    RAISE_APPLICATION_ERROR(-20001, 'Operation not allowed on weekdays or public holidays');
  ELSE
    log_audit_action(v_username, 'ALLOWED', 'GUESTS', 'ALLOWED');
  END IF;
END;
/
```

This helps enforce business rules and improve data security.

![Screenshot](screenshots/step7_trigger_restriction.png)

---

## âœ… Step 8: Compound Trigger for Multi-row Insert Audit on Payments

We use a compound trigger to audit multiple inserts into the `Payments` table in a single transaction, storing all relevant logs after all rows are processed.

```sql
CREATE OR REPLACE TRIGGER trg_multirow_audit
FOR INSERT ON Payments
COMPOUND TRIGGER

  TYPE audit_rec IS RECORD (
    uname VARCHAR2(50),
    op_date DATE,
    op_type VARCHAR2(10),
    tbl_name VARCHAR2(30),
    status VARCHAR2(10)
  );
  TYPE audit_tbl IS TABLE OF audit_rec;
  v_audits audit_tbl := audit_tbl();

BEFORE STATEMENT IS
BEGIN
  NULL;
END BEFORE STATEMENT;

AFTER EACH ROW IS
BEGIN
  v_audits.EXTEND;
  v_audits(v_audits.LAST) := audit_rec(
    SYS_CONTEXT('USERENV', 'SESSION_USER'),
    SYSDATE,
    'INSERT',
    'PAYMENTS',
    'ALLOWED'
  );
END AFTER EACH ROW;

AFTER STATEMENT IS
BEGIN
  FOR i IN 1 .. v_audits.COUNT LOOP
    INSERT INTO Audit_Log (UserName, ActionDate, Operation, TableName, Status)
    VALUES (v_audits(i).uname, v_audits(i).op_date, v_audits(i).op_type, v_audits(i).tbl_name, v_audits(i).status);
  END LOOP;
  COMMIT;
END AFTER STATEMENT;

END;
/
```

This demonstrates advanced PL/SQL auditing techniques.

![Screenshot](screenshots/step8_compound_trigger.png)

---

## âœ… Step 9: Test GetGuestSummary Procedure

We now run the stored procedure to display booking and payment details for a guest.

```sql
BEGIN
  GetGuestSummary(1);
END;
/
```

The output confirms that the procedure works and aggregates data correctly.

![Screenshot](screenshots/step9_test_summary.png)

---

## âœ… Step 10: Test INSERT Blocking Logic

Here we test whether the trigger blocks or allows an insert depending on the user and the day.

```sql
BEGIN
  INSERT INTO Guests (GuestID, Name, Contact, Email)
  VALUES (99, 'Blocked User', '0700000000', 'block@example.com');
END;
/

BEGIN
  INSERT INTO Guests (GuestID, Name, Contact, Email)
  VALUES (991, 'Blocked Usera', '070000000', 'blo1ck@example.com');
END;
/
```

This validates whether system rules are being enforced correctly.

![Screenshot](screenshots/step10_test_insert.png)

---

## âœ… Step 11: View Audit Log Records

Finally, we view the contents of the audit log to see all operations tracked by the system.

```sql
SELECT * FROM Audit_Log ORDER BY ActionDate DESC;
```

This gives us a complete log of who performed what actions and whether they were allowed.

![Screenshot](screenshots/step11_audit_log.png)

---

## âœ… Conclusion

This project implements a full hotel management system with automated record keeping, restricted access policies, and detailed audit logging. It demonstrates best practices in database design and PL/SQL development by combining:

- Stored procedures
- Advanced triggers
- Compound triggers
- Exception handling
- Autonomous transactions

The result is a secure, reliable, and efficient system for real-world hotel operations.
